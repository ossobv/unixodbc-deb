diff --git a/DriverManager/SQLConnect.c b/DriverManager/SQLConnect.c
index 8c4ae54..8fa295f 100644
--- a/DriverManager/SQLConnect.c
+++ b/DriverManager/SQLConnect.c
@@ -1090,6 +1090,9 @@ int __connect_part_one( DMHDBC connection, char *driver_lib, char *driver_name,
      */
 
     lt_dlinit();
+    mutex_lib_entry();
+    lt_dlsetsearchpath(MODULEDIR);
+    mutex_lib_exit();
 
     /*
      * open the lib
diff --git a/Drivers/Postgre7.1/md5.h b/Drivers/Postgre7.1/md5.h
index 2e2429d..2b16430 100644
--- a/Drivers/Postgre7.1/md5.h
+++ b/Drivers/Postgre7.1/md5.h
@@ -21,7 +21,7 @@
 
 #ifndef __cplusplus
 
-#ifndef bool
+#if !defined(bool) || defined(__APPLE_ALTIVEC__)
 typedef char bool;
 #endif
 
diff --git a/Drivers/nn/nnconfig.h b/Drivers/nn/nnconfig.h
index c47e6de..8d13d0a 100644
--- a/Drivers/nn/nnconfig.h
+++ b/Drivers/nn/nnconfig.h
@@ -21,6 +21,7 @@
 #  include	<stdlib.h>
 #  include	<errno.h>
 #  include	<sys/types.h>
+#  include	<string.h>
 
 #  define	MEM_ALLOC(size) (malloc((size_t)(size)))
 #  define	MEM_FREE(ptr)	{if(ptr) free(ptr);}
diff --git a/libltdl/libltdl/lt_dlloader.h b/libltdl/libltdl/lt_dlloader.h
index ae131fa..589fd0d 100644
--- a/libltdl/libltdl/lt_dlloader.h
+++ b/libltdl/libltdl/lt_dlloader.h
@@ -73,8 +73,8 @@ typedef struct {
 LT_SCOPE int		lt_dlloader_add	   (const lt_dlvtable *vtable);
 LT_SCOPE lt_dlloader	lt_dlloader_next   (const lt_dlloader loader);
 
-LT_SCOPE lt_dlvtable *	lt_dlloader_remove	(char *name);
-LT_SCOPE const lt_dlvtable *lt_dlloader_find	(char *name);
+LT_SCOPE lt_dlvtable *	lt_dlloader_remove	(const char *name);
+LT_SCOPE const lt_dlvtable *lt_dlloader_find	(const char *name);
 LT_SCOPE const lt_dlvtable *lt_dlloader_get	(lt_dlloader loader);
 
 
diff --git a/libltdl/libltdl/lt_system.h b/libltdl/libltdl/lt_system.h
index dab2ab6..f1545ce 100644
--- a/libltdl/libltdl/lt_system.h
+++ b/libltdl/libltdl/lt_system.h
@@ -1,6 +1,6 @@
 /* lt_system.h -- system portability abstraction layer
 
-   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2007, 2010 Free Software Foundation, Inc.
    Written by Gary V. Vaughan, 2004
 
    NOTE: The canonical source of this file is maintained with the
@@ -76,6 +76,18 @@ or obtained by writing to the Free Software Foundation, Inc.,
 #  endif
 #endif
 
+/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */
+#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
+/* DATA imports from DLLs on WIN32 con't be const, because runtime
+   relocations are performed -- see ld's documentation on pseudo-relocs.  */
+# define LT_DLSYM_CONST
+#elif defined(__osf__)
+/* This system does not cope well with relocations in const data.  */
+# define LT_DLSYM_CONST
+#else
+# define LT_DLSYM_CONST const
+#endif
+
 /* Canonicalise Windows and Cygwin recognition macros.
    To match the values set by recent Cygwin compilers, make sure that if
    __CYGWIN__ is defined (after canonicalisation), __WINDOWS__ is NOT!  */
diff --git a/libltdl/libltdl/slist.h b/libltdl/libltdl/slist.h
index e4b7ead..4d56509 100644
--- a/libltdl/libltdl/slist.h
+++ b/libltdl/libltdl/slist.h
@@ -1,6 +1,6 @@
 /* slist.h -- generalised singly linked lists
 
-   Copyright (C) 2000, 2004 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2004, 2009 Free Software Foundation, Inc.
    Written by Gary V. Vaughan, 2000
 
    NOTE: The canonical source of this file is maintained with the
@@ -48,6 +48,8 @@ or obtained by writing to the Free Software Foundation, Inc.,
 #  define LT_SCOPE
 #endif
 
+#include <stddef.h>
+
 #if defined(__cplusplus)
 extern "C" {
 #endif
@@ -65,7 +67,7 @@ LT_SCOPE SList *slist_concat	(SList *head, SList *tail);
 LT_SCOPE SList *slist_cons	(SList *item, SList *slist);
 
 LT_SCOPE SList *slist_delete	(SList *slist, void (*delete_fct) (void *item));
-LT_SCOPE void *	slist_remove	(SList **phead, SListCallback *find,
+LT_SCOPE SList *slist_remove	(SList **phead, SListCallback *find,
 				 void *matchdata);
 LT_SCOPE SList *slist_reverse	(SList *slist);
 LT_SCOPE SList *slist_sort	(SList *slist, SListCompare *compare,
diff --git a/libltdl/loaders/loadlibrary.c b/libltdl/loaders/loadlibrary.c
index 5644676..179c009 100644
--- a/libltdl/loaders/loadlibrary.c
+++ b/libltdl/loaders/loadlibrary.c
@@ -1,7 +1,7 @@
 /* loader-loadlibrary.c --  dynamic linking for Win32
 
    Copyright (C) 1998, 1999, 2000, 2004, 2005, 2006,
-                 2007, 2008 Free Software Foundation, Inc.
+                 2007, 2008, 2010 Free Software Foundation, Inc.
    Written by Thomas Tanner, 1998
 
    NOTE: The canonical source of this file is maintained with the
@@ -98,12 +98,32 @@ get_vtable (lt_user_data loader_data)
 
 #include <windows.h>
 
+#define LOCALFREE(mem)					     LT_STMT_START { \
+	if (mem) { LocalFree ((void *)mem); mem = NULL; }    } LT_STMT_END
+#define LOADLIB__SETERROR(errmsg) LT__SETERRORSTR (loadlibraryerror (errmsg))
+#define LOADLIB_SETERROR(errcode) LOADLIB__SETERROR (LT__STRERROR (errcode))
+
+static const char *loadlibraryerror (const char *default_errmsg);
+static DWORD WINAPI wrap_getthreaderrormode (void);
+static DWORD WINAPI fallback_getthreaderrormode (void);
+static BOOL WINAPI wrap_setthreaderrormode (DWORD mode, DWORD *oldmode);
+static BOOL WINAPI fallback_setthreaderrormode (DWORD mode, DWORD *oldmode);
+
+typedef DWORD (WINAPI getthreaderrormode_type) (void);
+typedef BOOL (WINAPI setthreaderrormode_type) (DWORD, DWORD *);
+
+static getthreaderrormode_type *getthreaderrormode = wrap_getthreaderrormode;
+static setthreaderrormode_type *setthreaderrormode = wrap_setthreaderrormode;
+static char *error_message = 0;
+
+
 /* A function called through the vtable when this loader is no
    longer needed by the application.  */
 static int
 vl_exit (lt_user_data LT__UNUSED loader_data)
 {
   vtable = NULL;
+  LOCALFREE (error_message);
   return 0;
 }
 
@@ -156,7 +176,7 @@ vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
 	  /* Append a `.' to stop Windows from adding an
 	     implicit `.dll' extension. */
 	  if (!len)
-	    len = LT_STRLEN (wpath);
+	    len = strlen (wpath);
 
 	  if (len + 1 >= MAX_PATH)
 	    {
@@ -170,16 +190,18 @@ vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
     }
 
   {
-    /* Silence dialog from LoadLibrary on some failures.
-       No way to get the error mode, but to set it,
-       so set it twice to preserve any previous flags. */
-    UINT errormode = SetErrorMode(SEM_FAILCRITICALERRORS);
-    SetErrorMode(errormode | SEM_FAILCRITICALERRORS);
+    /* Silence dialog from LoadLibrary on some failures. */
+    DWORD errormode = getthreaderrormode ();
+    DWORD last_error;
+
+    setthreaderrormode (errormode | SEM_FAILCRITICALERRORS, NULL);
 
     module = LoadLibrary (wpath);
 
     /* Restore the error mode. */
-    SetErrorMode(errormode);
+    last_error = GetLastError ();
+    setthreaderrormode (errormode, NULL);
+    SetLastError (last_error);
   }
 
   /* libltdl expects this function to fail if it is unable
@@ -207,7 +229,9 @@ vm_open (lt_user_data LT__UNUSED loader_data, const char *filename,
           }
       }
 
-    if (cur || !module)
+    if (!module)
+      LOADLIB_SETERROR (CANNOT_OPEN);
+    else if (cur)
       {
         LT__SETERROR (CANNOT_OPEN);
         module = 0;
@@ -225,9 +249,9 @@ vm_close (lt_user_data LT__UNUSED loader_data, lt_module module)
 {
   int errors = 0;
 
-  if (FreeLibrary((HMODULE) module) == 0)
+  if (FreeLibrary ((HMODULE) module) == 0)
     {
-      LT__SETERROR (CANNOT_CLOSE);
+      LOADLIB_SETERROR (CANNOT_CLOSE);
       ++errors;
     }
 
@@ -244,8 +268,102 @@ vm_sym (lt_user_data LT__UNUSED loader_data, lt_module module, const char *name)
 
   if (!address)
     {
-      LT__SETERROR (SYMBOL_NOT_FOUND);
+      LOADLIB_SETERROR (SYMBOL_NOT_FOUND);
     }
 
   return address;
 }
+
+
+
+/* --- HELPER FUNCTIONS --- */
+
+
+/* Return the windows error message, or the passed in error message on
+   failure. */
+static const char *
+loadlibraryerror (const char *default_errmsg)
+{
+  size_t len;
+  LOCALFREE (error_message);
+
+  FormatMessageA (FORMAT_MESSAGE_ALLOCATE_BUFFER |
+                  FORMAT_MESSAGE_FROM_SYSTEM |
+                  FORMAT_MESSAGE_IGNORE_INSERTS,
+                  NULL,
+                  GetLastError (),
+                  0,
+                  (char *) &error_message,
+                  0, NULL);
+
+  /* Remove trailing CRNL */
+  len = LT_STRLEN (error_message);
+  if (len && error_message[len - 1] == '\n')
+    error_message[--len] = LT_EOS_CHAR;
+  if (len && error_message[len - 1] == '\r')
+    error_message[--len] = LT_EOS_CHAR;
+
+  return len ? error_message : default_errmsg;
+}
+
+/* A function called through the getthreaderrormode variable which checks
+   if the system supports GetThreadErrorMode (or GetErrorMode) and arranges
+   for it or a fallback implementation to be called directly in the future.
+   The selected version is then called. */
+static DWORD WINAPI
+wrap_getthreaderrormode (void)
+{
+  HMODULE kernel32 = GetModuleHandleA ("kernel32.dll");
+  getthreaderrormode
+    = (getthreaderrormode_type *) GetProcAddress (kernel32,
+						  "GetThreadErrorMode");
+  if (!getthreaderrormode)
+    getthreaderrormode
+      = (getthreaderrormode_type *) GetProcAddress (kernel32,
+						    "GetErrorMode");
+  if (!getthreaderrormode)
+    getthreaderrormode = fallback_getthreaderrormode;
+  return getthreaderrormode ();
+}
+
+/* A function called through the getthreaderrormode variable for cases
+   where the system does not support GetThreadErrorMode or GetErrorMode */
+static DWORD WINAPI
+fallback_getthreaderrormode (void)
+{
+  /* Prior to Windows Vista, the only way to get the current error
+     mode was to set a new one. In our case, we are setting a new
+     error mode right after "getting" it while ignoring the error
+     mode in effect when setting the new error mode, so that's
+     fairly ok. */
+  return (DWORD) SetErrorMode (SEM_FAILCRITICALERRORS);
+}
+
+/* A function called through the setthreaderrormode variable which checks
+   if the system supports SetThreadErrorMode and arranges for it or a
+   fallback implementation to be called directly in the future.
+   The selected version is then called. */
+static BOOL WINAPI
+wrap_setthreaderrormode (DWORD mode, DWORD *oldmode)
+{
+  HMODULE kernel32 = GetModuleHandleA ("kernel32.dll");
+  setthreaderrormode
+    = (setthreaderrormode_type *) GetProcAddress (kernel32,
+						  "SetThreadErrorMode");
+  if (!setthreaderrormode)
+    setthreaderrormode = fallback_setthreaderrormode;
+  return setthreaderrormode (mode, oldmode);
+}
+
+/* A function called through the setthreaderrormode variable for cases
+   where the system does not support SetThreadErrorMode. */
+static BOOL WINAPI
+fallback_setthreaderrormode (DWORD mode, DWORD *oldmode)
+{
+  /* Prior to Windows 7, there was no way to set the thread local error
+     mode, so set the process global error mode instead. */
+  DWORD old = (DWORD) SetErrorMode (mode);
+  if (oldmode)
+    *oldmode = old;
+  return TRUE;
+}
diff --git a/libltdl/lt_dlloader.c b/libltdl/lt_dlloader.c
index 4e66a6c..2c99a22 100644
--- a/libltdl/lt_dlloader.c
+++ b/libltdl/lt_dlloader.c
@@ -150,7 +150,7 @@ lt_dlloader_get	(lt_dlloader loader)
    modules need this loader; in either case, the loader list is not
    changed if NULL is returned.  */
 lt_dlvtable *
-lt_dlloader_remove (char *name)
+lt_dlloader_remove (const char *name)
 {
   const lt_dlvtable *	vtable	= lt_dlloader_find (name);
   static const char	id_string[] = "lt_dlloader_remove";
@@ -199,12 +199,12 @@ lt_dlloader_remove (char *name)
 
   /* If we got this far, remove the loader from our global list.  */
   return (lt_dlvtable *)
-      slist_unbox ((SList *) slist_remove (&loaders, loader_callback, name));
+      slist_unbox ((SList *) slist_remove (&loaders, loader_callback, (void *) name));
 }
 
 
 const lt_dlvtable *
-lt_dlloader_find (char *name)
+lt_dlloader_find (const char *name)
 {
-  return lt_dlloader_get (slist_find (loaders, loader_callback, name));
+  return lt_dlloader_get (slist_find (loaders, loader_callback, (void *) name));
 }
diff --git a/libltdl/ltdl.c b/libltdl/ltdl.c
index 6e19599..01853e0 100644
--- a/libltdl/ltdl.c
+++ b/libltdl/ltdl.c
@@ -1,7 +1,7 @@
 /* ltdl.c -- system independent dlopen wrapper
 
    Copyright (C) 1998, 1999, 2000, 2004, 2005, 2006,
-		 2007, 2008 Free Software Foundation, Inc.
+		 2007, 2008, 2011 Free Software Foundation, Inc.
    Written by Thomas Tanner, 1998
 
    NOTE: The canonical source of this file is maintained with the
@@ -54,6 +54,10 @@ or obtained by writing to the Free Software Foundation, Inc.,
 #  define LT_LIBEXT "a"
 #endif
 
+#if !defined(LT_LIBPREFIX)
+#  define LT_LIBPREFIX "lib"
+#endif
+
 /* This is the maximum symbol size that won't require malloc/free */
 #undef	LT_SYMBOL_LENGTH
 #define LT_SYMBOL_LENGTH	128
@@ -72,9 +76,15 @@ or obtained by writing to the Free Software Foundation, Inc.,
 static	const char	objdir[]		= LT_OBJDIR;
 static	const char	archive_ext[]		= LT_ARCHIVE_EXT;
 static  const char	libext[]		= LT_LIBEXT;
+static  const char	libprefix[]		= LT_LIBPREFIX;
 #if defined(LT_MODULE_EXT)
 static	const char	shlib_ext[]		= LT_MODULE_EXT;
 #endif
+/* If the loadable module suffix is not the same as the linkable
+ * shared library suffix, this will be defined. */
+#if defined(LT_SHARED_EXT)
+static	const char	shared_ext[]		= LT_SHARED_EXT;
+#endif
 #if defined(LT_DLSEARCH_PATH)
 static	const char	sys_dlsearch_path[]	= LT_DLSEARCH_PATH;
 #endif
@@ -208,7 +218,7 @@ LT_BEGIN_C_DECLS
 LT_SCOPE const lt_dlvtable *	get_vtable (lt_user_data data);
 LT_END_C_DECLS
 #ifdef HAVE_LIBDLLOADER
-extern lt_dlsymlist		preloaded_symbols;
+extern LT_DLSYM_CONST lt_dlsymlist preloaded_symbols[];
 #endif
 
 /* Initialize libltdl. */
@@ -234,7 +244,7 @@ lt_dlinit (void)
 #ifdef HAVE_LIBDLLOADER
       if (!errors)
 	{
-	  errors += lt_dlpreload (&preloaded_symbols);
+	  errors += lt_dlpreload (preloaded_symbols);
 	}
 
       if (!errors)
@@ -529,7 +539,8 @@ find_module (lt_dlhandle *handle, const char *dir, const char *libdir,
   /* Try to open the old library first; if it was dlpreopened,
      we want the preopened version of it, even if a dlopenable
      module is available.  */
-  if (old_name && tryall_dlopen (handle, old_name, advise, 0) == 0)
+  if (old_name && tryall_dlopen (handle, old_name,
+			  advise, lt_dlloader_find ("lt_preopen") ) == 0)
     {
       return 0;
     }
@@ -993,7 +1004,7 @@ trim (char **dest, const char *str)
 
   FREE (*dest);
 
-  if (!end)
+  if (!end || end == str)
     return 1;
 
   if (len > 3 && str[0] == '\'')
@@ -1075,11 +1086,19 @@ parse_dotla_file(FILE *file, char **dlname, char **libdir, char **deplibs,
 	{
 	  errors += trim (old_name, &line[sizeof (STR_OLD_LIBRARY) - 1]);
 	}
+
+      /* Windows native tools do not understand the POSIX paths we store
+	 in libdir. */
 #undef  STR_LIBDIR
 #define STR_LIBDIR	"libdir="
       else if (strncmp (line, STR_LIBDIR, sizeof (STR_LIBDIR) - 1) == 0)
 	{
 	  errors += trim (libdir, &line[sizeof(STR_LIBDIR) - 1]);
+#ifdef __WINDOWS__
+	  /* Disallow following unix-style paths on MinGW.  */
+	  if (*libdir && (**libdir == '/' || **libdir == '\\'))
+	    **libdir = '\0';
+#endif
 	}
 
 #undef  STR_DL_DEPLIBS
@@ -1263,8 +1282,8 @@ try_dlopen (lt_dlhandle *phandle, const char *filename, const char *ext,
 
       if (vtable)
 	{
-	  /* name + "." + libext + NULL */
-	  archive_name = MALLOC (char, LT_STRLEN (name) + LT_STRLEN (libext) + 2);
+	  /* libprefix + name + "." + libext + NULL */
+	  archive_name = MALLOC (char, strlen (libprefix) + LT_STRLEN (name) + strlen (libext) + 2);
 	  *phandle = (lt_dlhandle) lt__zalloc (sizeof (struct lt__handle));
 
 	  if ((*phandle == NULL) || (archive_name == NULL))
@@ -1276,7 +1295,14 @@ try_dlopen (lt_dlhandle *phandle, const char *filename, const char *ext,
 
 	  /* Preloaded modules are always named according to their old
 	     archive name.  */
-	  sprintf (archive_name, "%s.%s", name, libext);
+	  if (strncmp(name, "lib", 3) == 0)
+	    {
+	      sprintf (archive_name, "%s%s.%s", libprefix, name + 3, libext);
+	    }
+	  else
+	    {
+	      sprintf (archive_name, "%s.%s", name, libext);
+	    }
 
 	  if (tryall_dlopen (&newhandle, archive_name, advise, vtable) == 0)
 	    {
@@ -1345,7 +1371,7 @@ try_dlopen (lt_dlhandle *phandle, const char *filename, const char *ext,
 	    }
 #endif
 	}
-      if (!file)
+      else
 	{
 	  file = fopen (attempt, LT_READTEXT_MODE);
 	}
@@ -1486,7 +1512,7 @@ try_dlopen (lt_dlhandle *phandle, const char *filename, const char *ext,
 }
 
 
-/* If the last error messge store was `FILE_NOT_FOUND', then return
+/* If the last error message stored was `FILE_NOT_FOUND', then return
    non-zero.  */
 static int
 file_not_found (void)
@@ -1506,7 +1532,7 @@ file_not_found (void)
 static int
 has_library_ext (const char *filename)
 {
-  char *	ext     = 0;
+  const char *	ext     = 0;
 
   assert (filename);
 
@@ -1516,6 +1542,9 @@ has_library_ext (const char *filename)
 #if defined(LT_MODULE_EXT)
 	     || (streq (ext, shlib_ext))
 #endif
+#if defined(LT_SHARED_EXT)
+	     || (streq (ext, shared_ext))
+#endif
     ))
     {
       return 1;
@@ -1614,6 +1643,9 @@ lt_dlopenadvise (const char *filename, lt_dladvise advise)
 {
   lt_dlhandle	handle	= 0;
   int		errors	= 0;
+  const char *	saved_error	= 0;
+
+  LT__GETERROR (saved_error);
 
   /* Can't have symbols hidden and visible at the same time!  */
   if (advise && advise->is_symlocal && advise->is_symglobal)
@@ -1650,6 +1682,7 @@ lt_dlopenadvise (const char *filename, lt_dladvise advise)
 
 #if defined(LT_MODULE_EXT)
       /* Try appending SHLIB_EXT.   */
+      LT__SETERRORSTR (saved_error);
       errors = try_dlopen (&handle, filename, shlib_ext, advise);
 
       /* As before, if the file was found but loading failed, return now
@@ -1657,6 +1690,17 @@ lt_dlopenadvise (const char *filename, lt_dladvise advise)
       if (handle || ((errors > 0) && !file_not_found ()))
 	return handle;
 #endif
+
+#if defined(LT_SHARED_EXT)
+      /* Try appending SHARED_EXT.   */
+      LT__SETERRORSTR (saved_error);
+      errors = try_dlopen (&handle, filename, shared_ext, advise);
+
+      /* As before, if the file was found but loading failed, return now
+	 with the current error message.  */
+      if (handle || ((errors > 0) && !file_not_found ()))
+	return handle;
+#endif
     }
 
   /* Still here?  Then we really did fail to locate any of the file
@@ -2061,7 +2105,7 @@ lt_dlerror (void)
   LT__GETERROR (error);
   LT__SETERRORSTR (0);
 
-  return error ? error : NULL;
+  return error;
 }
 
 static int
diff --git a/libltdl/ltdl.h b/libltdl/ltdl.h
index 8b516ad..749a54d 100644
--- a/libltdl/ltdl.h
+++ b/libltdl/ltdl.h
@@ -102,10 +102,11 @@ LT_SCOPE int	lt_dlpreload_open    (const char *originator,
 				      lt_dlpreload_callback_func *func);
 
 #define lt_preloaded_symbols	lt__PROGRAM__LTX_preloaded_symbols
-#define LTDL_SET_PRELOADED_SYMBOLS() 			LT_STMT_START{	\
-	extern const lt_dlsymlist lt_preloaded_symbols[];		\
-	lt_dlpreload_default(lt_preloaded_symbols);			\
-							}LT_STMT_END
+/* Ensure C linkage.  */
+extern LT_DLSYM_CONST lt_dlsymlist lt__PROGRAM__LTX_preloaded_symbols[];
+
+#define LTDL_SET_PRELOADED_SYMBOLS() \
+	lt_dlpreload_default(lt_preloaded_symbols)
 
 
 
diff --git a/libltdl/slist.c b/libltdl/slist.c
index c99f399..25906a4 100644
--- a/libltdl/slist.c
+++ b/libltdl/slist.c
@@ -1,6 +1,6 @@
 /* slist.c -- generalised singly linked lists
 
-   Copyright (C) 2000, 2004, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2004, 2007, 2008, 2009 Free Software Foundation, Inc.
    Written by Gary V. Vaughan, 2000
 
    NOTE: The canonical source of this file is maintained with the
@@ -32,6 +32,7 @@ or obtained by writing to the Free Software Foundation, Inc.,
 
 #include "slist.h"
 #include <stddef.h>
+#include <stdlib.h>
 
 static SList *	slist_sort_merge    (SList *left, SList *right,
 				     SListCompare *compare, void *userdata);
@@ -73,7 +74,7 @@ slist_delete (SList *head, void (*delete_fct) (void *item))
            the stale item, you should probably return that from FIND if
 	   it makes a successful match.  Don't forget to slist_unbox()
 	   every item in a boxed list before operating on its contents.   */
-void *
+SList *
 slist_remove (SList **phead, SListCallback *find, void *matchdata)
 {
   SList *stale = 0;
@@ -107,7 +108,7 @@ slist_remove (SList **phead, SListCallback *find, void *matchdata)
 	}
     }
 
-  return result;
+  return (SList *) result;
 }
 
 /* Call FIND repeatedly with each element of SLIST and MATCHDATA, until
@@ -314,6 +315,9 @@ slist_sort (SList *slist, SListCompare *compare, void *userdata)
   left = slist;
   right = slist->next;
 
+  if (!right)
+    return left;
+
   /* Skip two items with RIGHT and one with SLIST, until RIGHT falls off
      the end.  SLIST must be about half way along.  */
   while (right && (right = right->next))
diff --git a/odbcinst/ODBCINSTConstructProperties.c b/odbcinst/ODBCINSTConstructProperties.c
index 8703d02..b9ab4fe 100644
--- a/odbcinst/ODBCINSTConstructProperties.c
+++ b/odbcinst/ODBCINSTConstructProperties.c
@@ -165,6 +165,7 @@ int ODBCINSTConstructProperties( char *pszDriver, HODBCINSTPROPERTY *hFirstPrope
      */
 
     lt_dlinit();
+    lt_dlsetsearchpath(MODULEDIR);
 
 	/* TRY GET FUNC FROM DRIVER SETUP */
 	if ( !(hDLL = lt_dlopen( szDriverSetup ))  )
diff --git a/odbcinst/SQLConfigDataSource.c b/odbcinst/SQLConfigDataSource.c
index af7f42f..a6763ff 100644
--- a/odbcinst/SQLConfigDataSource.c
+++ b/odbcinst/SQLConfigDataSource.c
@@ -80,6 +80,7 @@ static BOOL SQLConfigDataSourceWide(	HWND	hWnd,
      */
 
     lt_dlinit();
+    lt_dlsetsearchpath(MODULEDIR);
 
 #ifdef PLATFORM64
 	if ( iniPropertySeek( hIni, (char *)pszDriver, "Setup64", "" ) == INI_SUCCESS || 
diff --git a/odbcinst/SQLConfigDriver.c b/odbcinst/SQLConfigDriver.c
index 3637381..ce7d68b 100644
--- a/odbcinst/SQLConfigDriver.c
+++ b/odbcinst/SQLConfigDriver.c
@@ -86,6 +86,7 @@ static BOOL SQLConfigDriverWide( HWND	hWnd,
      */
 
     lt_dlinit();
+    lt_dlsetsearchpath(MODULEDIR);
 
 	/* process request */
 	switch ( nRequest )
diff --git a/odbcinst/SQLCreateDataSource.c b/odbcinst/SQLCreateDataSource.c
index f951c5d..d2745a0 100644
--- a/odbcinst/SQLCreateDataSource.c
+++ b/odbcinst/SQLCreateDataSource.c
@@ -196,6 +196,7 @@ BOOL SQLCreateDataSource( HWND hWnd, LPCSTR pszDS )
         inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_GENERAL_ERR, "lt_dlinit() failed" );
         return FALSE;
     }
+    lt_dlsetsearchpath(MODULEDIR);
 
     /* get plugin name */
     _appendUIPluginExtension( szNameAndExtension, _getUIPluginName( szName, hODBCInstWnd->szUI ) );
diff --git a/odbcinst/SQLManageDataSources.c b/odbcinst/SQLManageDataSources.c
index 0eea527..953eb1d 100644
--- a/odbcinst/SQLManageDataSources.c
+++ b/odbcinst/SQLManageDataSources.c
@@ -76,9 +76,9 @@ char *_getUIPluginName( char *pszName, char *pszUI )
 char *_appendUIPluginExtension( char *pszNameAndExtension, char *pszName )
 {
     if ( strlen( SHLIBEXT ) > 0 )
-        sprintf( pszNameAndExtension, "%s%s", pszName, SHLIBEXT );
+        sprintf( pszNameAndExtension, "%s%s.1", pszName, SHLIBEXT );
     else
-        sprintf( pszNameAndExtension, "%s.so", pszName );
+        sprintf( pszNameAndExtension, "%s.so.1", pszName );
 
     return pszName;
 }
@@ -143,6 +143,7 @@ BOOL SQLManageDataSources( HWND hWnd )
         inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_GENERAL_ERR, "lt_dlinit() failed" );
 		return FALSE;
     }
+    lt_dlsetsearchpath(MODULEDIR);
 
     /* get plugin name */
     _appendUIPluginExtension( szNameAndExtension, _getUIPluginName( szName, hODBCInstWnd->szUI ) );
diff --git a/odbcinst/_SQLGetInstalledDrivers.c b/odbcinst/_SQLGetInstalledDrivers.c
index b5d22ab..2ccbf07 100644
--- a/odbcinst/_SQLGetInstalledDrivers.c
+++ b/odbcinst/_SQLGetInstalledDrivers.c
@@ -55,9 +55,9 @@ int _SQLGetInstalledDrivers(    LPCSTR  pszSection,
 
     /* PROCESS ODBC INI FILE */
 #ifdef __OS2__
-    if ( iniOpen( &hIni, szIniName, "#;", '[', ']', '=', 1, 1L ) != INI_SUCCESS )
+    if ( iniOpen( &hIni, szIniName, "#;", '[', ']', '=', FALSE, 1L ) != INI_SUCCESS )
 #else
-    if ( iniOpen( &hIni, szIniName, "#;", '[', ']', '=', 1 ) != INI_SUCCESS )
+    if ( iniOpen( &hIni, szIniName, "#;", '[', ']', '=', FALSE ) != INI_SUCCESS )
 #endif
     {
         inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_COMPONENT_NOT_FOUND, "" );
